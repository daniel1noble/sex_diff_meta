kable(print.rma.mv(smd_mods$bird, digits = NULL))
unlist(lapply(smd_mods, function(x) kable(print.rma.mv(x))))
unlist(lapply(smd_mods, function(x) kable(print.rma.mv(x))))
smd_mods$bird
summary(smd_mods$bird)
summary(smd_mods$bird)
summary(smd_mods$bird)$coef
str(summary(smd_mods$bird))
summary(smd_mods$bird)
cat(summary(smd_mods$bird))
MLMA_estimates_SMD
# Now that we have our list of models, we can extract the estimates, CIs and prediction intervals
MLMA_estimates_SMD <- plyr::ldply(lapply(smd_mods, function(x) print(mod_results(x, mod = "Int"))))
MLMA_estimates_SMD
# Clear work space
# rm(list=ls())
# Install CRAN packages
library("pacman")
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
devtools::install_github("daniel1noble/metaAidR");
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
# set working directory
# setwd("~/Documents/GitHub/sex_meta/")
# Source our own functions
source("./R/func.R")
# Set the rerun object to FALSE so that you don't need to re-run all models again. Some take quite a lot of time to run. If FALSE, it will just re-load saved output.
rerun_models = FALSE
knitr::opts_chunk$set(echo = TRUE)
# Install CRAN packages
library("pacman")
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
devtools::install_github("daniel1noble/metaAidR");
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
setwd("~/Documents/GitHub/sex_meta/")
# Source our own functions
source("./R/func.R")
## load our original pers dataset and our dataset with all of our sexual selection info
pers <- read.csv("./data/pers_data.csv", stringsAsFactors = FALSE)
bodysize <- read.csv("./data/bodysize_SSD.csv", stringsAsFactors = FALSE)
## Merge the two by spp_names columns
pers <- merge(x = pers,
y = bodysize[,c("species_name", "SSD_index", "mating_system")],
by="species_name", all.x=TRUE,  no.dups = TRUE)
## Select only the relevant columns to make life easier
pers_new <- pers %>%
select(study_ID, year, species_name, SSD_index, taxo_group, data_type, personality_trait, male_n, male_mean_conv,
male_sd_conv, female_n, female_mean_conv, female_sd_conv, depend, directionality, spp_name_phylo, mating_system,
age, population, study_environment, study_type, measurement_type)
## Add in observation level random effect (metafor doesn't do this, need to do it manually)
pers_new <- pers_new %>%
group_by(taxo_group) %>%
mutate(obs = 1:length(study_ID))
## SMD (Hedges' g)
pers_new <- escalc(measure = "SMD",
n1i = male_n, n2i = female_n,
m1i = male_mean_conv, m2i = female_mean_conv,
sd1i = male_sd_conv, sd2i = female_sd_conv, data = pers_new, var.names=c("SMD_yi","SMD_vi"), append = TRUE)
## lnCVR
pers_new <- escalc(measure = "CVR",
n2i = female_n, n1i = male_n,
m2i = female_mean_conv, m1i = male_mean_conv,
sd2i = female_sd_conv, sd1i = male_sd_conv, data = pers_new, var.names=c("CVR_yi","CVR_vi"))
# Exclude NAs
pers_new <- pers_new %>%
filter(!is.na(CVR_yi), !is.na(SMD_yi))
dim(pers_new)    # check they've been removed with no issues
funnel(x = pers_new$CVR_yi, vi = pers_new$CVR_vi, yaxis="seinv", xlim = c(-10, 10))
funnel(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, yaxis="seinv")
text(as.character(pers_new$study_ID), x = pers_new$SMD_yi, y = 1/sqrt(pers_new$SMD_vi))
funnel(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, yaxis="seinv")
text(as.character(pers_new$study_ID), x = pers_new$SMD_yi, y = 1/sqrt(pers_new$SMD_vi))
pers_new %>%
filter(study_ID == "P015" & SMD_yi < -15) # P015 has 1 large effect size, remove?
# filter out that large effect size
pers_new <- pers_new %>%
filter(!study_ID == "P015" | !obs == "509")
dim(pers_new)
# checking SMD outliers - inverse SE > 14
funnel(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, yaxis="seinv")
# remove these by study
pers_new <- pers_new %>% filter(!study_ID == "P029" | !obs %in% c("21", "25", "26", "28", "31"))
pers_new <- pers_new %>% filter(!study_ID == "P084" | !obs %in% c("59", "62", "63", "65", "68", "70", "71", "72", "74"))
pers_new <-  pers_new %>% filter(!study_ID == "P060" | !obs %in% c("216", "217"))
pers_new <- pers_new %>% filter(!study_ID == "P211" | !obs %in% c("230", "245"))
pers_new <- pers_new %>% filter(!study_ID == "P117" | !obs %in% c("397", "393", "402", "414"))
pers_new <- pers_new %>% filter(!study_ID == "P197" | !obs %in% c("541", "544", "546", "547"))
pers_new <- pers_new %>% filter(!study_ID == "P197" | !obs %in% c("669", "672", "673", "682", "683", "684", "686", "694"))
pers_new <- pers_new %>% filter(!study_ID == "P041" | !obs %in% c("120", "124"))
dim(pers_new) # check they've been removed without issue
pers_new <- pers_new %>% filter(!study_ID == "P100" | !obs == "519") # big outlier
pers_new$directionality <- ifelse(is.na(pers_new$directionality), 0, 1)
pers_new$SMD_yi_flip <- ifelse(pers_new$directionality == 1, pers_new$SMD_yi*(-1), pers_new$SMD_yi)
# Find all tree file names
tree_files <- paste0("./trees/", list.files("./trees"))[-1]
# Bird tree has been constructed already, just need to get trees for the rest of the taxo groups
trees <- lapply(tree_files, function(x) read.tree(x))
names <- gsub("~./trees/", "", tree_files)
names(trees) <- names
# Plot the trees and see how they look
par(mfrow = c(1,5), mar = c(1,1,1,1))
lapply(trees, function(x) plot(x, cex = 1))
# Check that they are ultrametric
lapply(trees, function(x) is.ultrametric(x))
# Check that all names in the phylogeny are also in the data
taxa_data_list <- split(pers_new, pers_new$taxo_group)
other_groups <- mapply(x = taxa_data_list,
y = trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
# Print out each taxon group
for(i in colnames(other_groups)){
print(i)
print(other_groups[,i] )
}
# Now to prune trees so that we get tree names that match with species in data
pruned_trees <- mapply(x = taxa_data_list,
y = trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "prune"))
# Check that this has been done correctly
re_checks <- mapply(x = taxa_data_list,
y = pruned_trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
for(i in colnames(re_checks)){
print(i)
print(re_checks[,i] )
}
# Extract the phylogenetic correlation matrices
phylo_vcv <- lapply(pruned_trees, function(x) vcv(x, corr = TRUE)) # these matrices are used in the meta-a models
# make a new column where data type is binary (score or other)
pers_new$score <- ifelse(pers_new$measurement_type == "score", "score", "other")
# how many effect sizes are scores?
data.frame(pers_new %>%
group_by(taxo_group, score) %>%
summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))))
# model:
sensitivity_mod1_score <- meta_model_fits(pers_new, phylo_vcv, type = "score")
# Extract the SMD and lnCVR results
smd_mods_score <- sensitivity_mod1_score["SMD",]
lnCVR_mods_score <- sensitivity_mod1_score["lnCVR",] # inverts significant
smd_mods_score
smd_mods_score
lnCVR_mods_score
# filter out invert scores from pers dataset
pers_new <- pers_new %>%
filter(score != "score" | taxo_group != "invertebrate")
dim(pers_new)
data.frame(pers_new %>%
summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))))
MLMA_models <- meta_model_fits(pers_new, phylo_vcv, type = "int")
# View model results
split_taxa <- split(pers_new, pers_new$taxo_group)
smd_mods <- MLMA_models["SMD",]
lnCVR_mods <- MLMA_models["lnCVR",]
smd_mods
MLMR_models_pers_trait <- readRDS("./output/MLMR_models_pers_trait")
# Extract the SMD and lnCVR results
smd_mods_pers <- MLMR_models_pers_trait["SMD",]
lnCVR_mods_pers <- MLMR_models_pers_trait["lnCVR",]
smd_mods_pers
smd_mods_pers
MLMR_models_pers_trait
# Extract the SMD and lnCVR results
smd_mods_pers <- MLMR_models_pers_trait["SMD",]
lnCVR_mods_pers <- MLMR_models_pers_trait["lnCVR",]
smd_mods_pers
# Extract the SMD and lnCVR results
smd_mods_pers <- MLMR_models_pers_trait["SMD"]
smd_mods_pers
MLMR_models_pers_trait <- meta_model_fits(pers_new, phylo_vcv, type = "pers")
# Extract the SMD and lnCVR results
smd_mods_pers <- MLMR_models_pers_trait["SMD",]
lnCVR_mods_pers <- MLMR_models_pers_trait["lnCVR",]
smd_mods_pers
MLMR_models_pers_SSD <- meta_model_fits(pers_new, phylo_vcv, type = "pers_SSD")
# Extract the SMD and lnCVR results
smd_mods_pers_SSD <- MLMR_models_pers_SSD["SMD",]
lnCVR_mods_pers_SSD <- MLMR_models_pers_SSD["lnCVR",]
smd_mods_pers_SSD
# extract estimates using modified function in func.R file:
# SMD
MLMA_estimates_SMD_SSD <- plyr::ldply(lapply(smd_mods_pers_SSD, function(x)
print(mod_results_new(x, mod_cat = "personality_trait", mod_cont = "SSD_index", type = "zero"))))
MLMA_estimates_SMD_SSD
# lnCVR
MLMA_estimates_lnCVR_SSD <- plyr::ldply(lapply(lnCVR_mods_pers_SSD, function(x)
print(mod_results_new(x, mod_cat = "personality_trait", mod_cont = "SSD_index", type = "zero"))))
MLMA_estimates_lnCVR_SSD
# Table to get species numbers, no. studies and no. effect sizes:
data.frame(pers_new %>%
group_by(taxo_group, personality_trait) %>%
filter(!is.na(SSD_index))%>%
summarise(n = n(), N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))
MLMA_estimates_SMD_SSD
MLMA_estimates_lnCVR_SSD
smd_mods_pers_SSD
lnCVR_mods_pers_SSD
MLMR_models_pers_mating_system <- meta_model_fits(pers_new, phylo_vcv, type = "pers_mate")
# Extract the SMD and lnCVR results
smd_mods_mating_system <- MLMR_models_pers_mating_system["SMD",]
lnCVR_mods_mating_system <- MLMR_models_pers_mating_system["lnCVR",]
smd_mods_mating_system
MLMR_models_pers_age <- meta_model_fits(pers_new, phylo_vcv, type = "age")
# Extract the SMD and lnCVR results
smd_mods_pers_age <- MLMR_models_pers_age["SMD",]
lnCVR_mods_pers_age <- MLMR_models_pers_age["lnCVR",]
smd_mods_pers_age
# calculating the inverse of the 'effective sample size' to account for unbalanced sampling
pers_new$inv_n_tilda <- with(pers_new, ((female_n + male_n)/(female_n*male_n)))
pers_new$sqrt_inv_n_tilda <- with(pers_new, (sqrt(inv_n_tilda))) # use this first, if significant, then use the 1st one
MLMR_models_pers_pubbias <- meta_model_fits(pers_new, phylo_vcv, type = "pubbias")
# Extract the SMD and lnCVR results
smd_mods_pubbias <- MLMR_models_pers_pubbias["SMD",]
lnCVR_mods_pubbias <- MLMR_models_pers_pubbias["lnCVR",] # evidence of publication bias for inverts
smd_mods_pubbias
lnCVR_mods_pubbias
# calculating the inverse of the 'effective sample size' to account for unbalanced sampling
pers_new$inv_n_tilda <- with(pers_new, ((4*(female_n + male_n))/(female_n*male_n)))
pers_new$sqrt_inv_n_tilda <- with(pers_new, (sqrt(inv_n_tilda))) # use this first, if significant, then use the 1st one
MLMR_models_pers_pubbias <- meta_model_fits(pers_new, phylo_vcv, type = "pubbias")
# calculating the inverse of the 'effective sample size' to account for unbalanced sampling
pers_new$inv_n_tilda <- with(pers_new, ((female_n + male_n))/(female_n*male_n))
pers_new$sqrt_inv_n_tilda <- with(pers_new, (sqrt(inv_n_tilda))) # use this first, if significant, then use the 1st one
MLMR_models_pers_pubbias <- meta_model_fits(pers_new, phylo_vcv, type = "pubbias")
# Extract the SMD and lnCVR results
smd_mods_pubbias <- MLMR_models_pers_pubbias["SMD",]
lnCVR_mods_pubbias <- MLMR_models_pers_pubbias["lnCVR",] # evidence of publication bias for inverts
smd_mods_pubbias
lnCVR_mods_pubbias
lnCVR_mods_pubbias
# install packages to make diagonal matrix and to make multiple comparisons
library(multcomp)
library(Matrix)
# Create block diag phylogeny
phylogeny <- Matrix::bdiag(phylo_vcv_bird, phylo_vcv_mammal) # use this as the phylo vcv in the model
# Extract the phylogenetic correlation matrices
phylo_vcv_mammal <- phylo_vcv[[4]]
# phylo_vcv birds only
phylo_vcv_bird <- phylo_vcv[[1]]
# Create block diag phylogeny
phylogeny <- Matrix::bdiag(phylo_vcv_bird, phylo_vcv_mammal) # use this as the phylo vcv in the model
# needs to have colnames for use in random effects model
dimnames(phylogeny) <- Map(c, dimnames(phylo_vcv_bird), dimnames(phylo_vcv_mammal))
# only include bird and mammal data
pers_new_contrast <- as.data.frame(pers_new %>%
filter(taxo_group =="mammal" | taxo_group == "bird") %>%
mutate(sp_pers = interaction(personality_trait,taxo_group)))
# model with interaction only to check output of model above
contrast_birdmammal_lncvr_2 <- rma.mv(CVR_yi ~ sp_pers -1, V = CVR_vi,
random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs),
R = list(spp_name_phylo=phylogeny), control=list(optimizer="optim"),
test = "t", data = pers_new_contrast)
# try this one
contrast_heterogamety <- glht(contrast_birdmammal_lncvr_2, linfct=mcp(sp_pers = "Tukey"), test=adjusted("fdr"))
# try this one
contrast_heterogamety <- summary(glht(contrast_birdmammal_lncvr_2, linfct=mcp(sp_pers = "Tukey"), test=adjusted("fdr")))
# try this one
contrast_heterogamety <- summary(glht(contrast_birdmammal_lncvr_2, linfct=mcp(sp_pers = "Tukey")))
#lnCVR model only
contrast_birdmammal_lncvr <- rma.mv(CVR_yi ~ personality_trait*taxo_group, V = CVR_vi,
random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs),
R = list(spp_name_phylo=phylogeny), control=list(optimizer="optim"),
test = "t", data = pers_new_contrast)
# try this one
contrast_heterogamety <- summary(glht(contrast_birdmammal_lncvr, linfct=mcp(personality_trait = "Tukey")))
# multiple comparison using Tukey test
summary(glht(contrast_birdmammal_lncvr, linfct = cbind(contrMat(rep(1,10), type = "Tukey"))), test=adjusted("fdr"))
# multiple comparison using Tukey test
summary(glht(contrast_birdmammal_lncvr, linfct = cbind(contrMat(rep(1,10), type = "GrandMean"))), test=adjusted("fdr"))
# multiple comparison using Tukey test
summary(glht(contrast_birdmammal_lncvr, linfct = cbind(contrMat(rep(1,10), base = 2))), test=adjusted("fdr"))
# multiple comparison using Tukey test
summary(glht(contrast_birdmammal_lncvr, linfct = cbind(contrMat(rep(1,10), type = "Tukey"))), test=adjusted("fdr"))
# multiple comparison using Tukey test
summary(glht(contrast_birdmammal_lncvr, linfct = cbind(contrMat(rep(1,10), type = "Tukey"))), test=adjusted("fdr"))
# multiple comparison using Tukey test
summary(glht(contrast_birdmammal_lncvr, linfct = cbind(contrMat(rep(1:10), type = "Tukey"))), test=adjusted("fdr"))
rm(list=ls())
# Install CRAN packages
library("pacman")
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
devtools::install_github("daniel1noble/metaAidR");
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
setwd("~/Documents/GitHub/sex_meta/")
# Source our own functions
source("./R/func.R")
## load our original pers dataset and our dataset with all of our sexual selection info
pers <- read.csv("./data/pers_data.csv", stringsAsFactors = FALSE)
bodysize <- read.csv("./data/bodysize_SSD.csv", stringsAsFactors = FALSE)
## Merge the two by spp_names columns
pers <- merge(x = pers,
y = bodysize[,c("species_name", "SSD_index", "mating_system")],
by="species_name", all.x=TRUE,  no.dups = TRUE)
## Select only the relevant columns to make life easier
pers_new <- pers %>%
select(study_ID, year, species_name, SSD_index, taxo_group, data_type, personality_trait, male_n, male_mean_conv,
male_sd_conv, female_n, female_mean_conv, female_sd_conv, depend, directionality, spp_name_phylo, mating_system,
age, population, study_environment, study_type, measurement_type)
pers_new <- pers %>%
select(study_ID, year, species_name, SSD_index, taxo_group, data_type, personality_trait, male_n, male_mean_conv,
male_sd_conv, female_n, female_mean_conv, female_sd_conv, depend, directionality, spp_name_phylo, mating_system,
age, population, study_environment, study_type, measurement_type)
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
# Install CRAN packages
library("pacman")
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
devtools::install_github("daniel1noble/metaAidR");
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
setwd("~/Documents/GitHub/sex_meta/")
# Source our own functions
source("./R/func.R")
## load our original pers dataset and our dataset with all of our sexual selection info
pers <- read.csv("./data/pers_data.csv", stringsAsFactors = FALSE)
bodysize <- read.csv("./data/bodysize_SSD.csv", stringsAsFactors = FALSE)
## Merge the two by spp_names columns
pers <- merge(x = pers,
y = bodysize[,c("species_name", "SSD_index", "mating_system")],
by="species_name", all.x=TRUE,  no.dups = TRUE)
## Select only the relevant columns to make life easier
pers_new <- pers %>%
select(study_ID, year, species_name, SSD_index, taxo_group, data_type, personality_trait, male_n, male_mean_conv,
male_sd_conv, female_n, female_mean_conv, female_sd_conv, depend, directionality, spp_name_phylo, mating_system,
age, population, study_environment, study_type, measurement_type)
## Add in observation level random effect (metafor doesn't do this, need to do it manually)
pers_new <- pers_new %>%
group_by(taxo_group) %>%
mutate(obs = 1:length(study_ID))
data.frame(pers_new %>%
summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))))
data.frame(pers_new %>%
summarise(n = n(), studies = length(unique(study_ID))))
data.frame(pers_new %>%
studies = length(unique(study_ID))))
data.frame(pers_new %>%
summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))))
data.frame(pers_new %>%
summarise(n = n(), N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))
sapply(pers_new, function(x) length(unique(study_ID))
)
length(unique(pers_new$study_ID))
## SMD (Hedges' g)
pers_new <- escalc(measure = "SMD",
n1i = male_n, n2i = female_n,
m1i = male_mean_conv, m2i = female_mean_conv,
sd1i = male_sd_conv, sd2i = female_sd_conv, data = pers_new, var.names=c("SMD_yi","SMD_vi"), append = TRUE)
## lnCVR
pers_new <- escalc(measure = "CVR",
n2i = female_n, n1i = male_n,
m2i = female_mean_conv, m1i = male_mean_conv,
sd2i = female_sd_conv, sd1i = male_sd_conv, data = pers_new, var.names=c("CVR_yi","CVR_vi"))
# Exclude NAs
pers_new <- pers_new %>%
filter(!is.na(CVR_yi), !is.na(SMD_yi))
dim(pers_new)    # check they've been removed with no issues
length(unique(pers_new$study_ID))
pers_new %>%
filter(study_ID == "P015" & SMD_yi < -15) # P015 has 1 large effect size, remove?
# filter out that large effect size
pers_new <- pers_new %>%
filter(!study_ID == "P015" | !obs == "509")
dim(pers_new)
# remove these by study
pers_new <- pers_new %>% filter(!study_ID == "P029" | !obs %in% c("21", "25", "26", "28", "31"))
pers_new <- pers_new %>% filter(!study_ID == "P084" | !obs %in% c("59", "62", "63", "65", "68", "70", "71", "72", "74"))
pers_new <-  pers_new %>% filter(!study_ID == "P060" | !obs %in% c("216", "217"))
pers_new <- pers_new %>% filter(!study_ID == "P211" | !obs %in% c("230", "245"))
pers_new <- pers_new %>% filter(!study_ID == "P117" | !obs %in% c("397", "393", "402", "414"))
pers_new <- pers_new %>% filter(!study_ID == "P197" | !obs %in% c("541", "544", "546", "547"))
pers_new <- pers_new %>% filter(!study_ID == "P197" | !obs %in% c("669", "672", "673", "682", "683", "684", "686", "694"))
pers_new <- pers_new %>% filter(!study_ID == "P041" | !obs %in% c("120", "124"))
dim(pers_new) # check they've been removed without issue
pers_new <- pers_new %>% filter(!study_ID == "P100" | !obs == "519") # big outlier
length(unique(pers_new$study_ID))
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
# Install CRAN packages
library("pacman")
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
devtools::install_github("daniel1noble/metaAidR");
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
setwd("~/Documents/GitHub/sex_meta/")
# Source our own functions
source("./R/func.R")
pers_new <- read.csv("./data/pers_new.csv", stringsAsFactors = FALSE)
# Find all tree file names
tree_files <- paste0("./trees/", list.files("./trees"))[-1]
# Bird tree has been constructed already, just need to get trees for the rest of the taxo groups
trees <- lapply(tree_files, function(x) read.tree(x))
names <- gsub("~./trees/", "", tree_files)
names(trees) <- names
# Plot the trees and see how they look
par(mfrow = c(1,5), mar = c(1,1,1,1))
lapply(trees, function(x) plot(x, cex = 1))
# Check that they are ultrametric
lapply(trees, function(x) is.ultrametric(x))
# Check that all names in the phylogeny are also in the data
taxa_data_list <- split(pers_new, pers_new$taxo_group)
other_groups <- mapply(x = taxa_data_list,
y = trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
# Print out each taxon group
for(i in colnames(other_groups)){
print(i)
print(other_groups[,i] )
}
# Now to prune trees so that we get tree names that match with species in data
pruned_trees <- mapply(x = taxa_data_list,
y = trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "prune"))
# Check that this has been done correctly
re_checks <- mapply(x = taxa_data_list,
y = pruned_trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
for(i in colnames(re_checks)){
print(i)
print(re_checks[,i] )
}
# Extract the phylogenetic correlation matrices
phylo_vcv <- lapply(pruned_trees, function(x) vcv(x, corr = TRUE)) # these matrices are used in the meta-a models
data.frame(pers_new %>%
group_by(taxo_group, score) %>%
summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))))
# calculating the inverse of the 'effective sample size' to account for unbalanced sampling
pers_new$inv_n_tilda <- with(pers_new, ((female_n + male_n))/4*(female_n*male_n))
pers_new$sqrt_inv_n_tilda <- with(pers_new, (sqrt(inv_n_tilda))) # use this first, if significant, then use the 1st one
MLMR_models_pers_pubbias <- meta_model_fits(pers_new, phylo_vcv, type = "pubbias")
fit_MLMA_reg_models_pubbias <- function(data, phylo_vcv){
lnCVR <- metafor::rma.mv(CVR_yi ~ -1 + personality_trait + sqrt_inv_n_tilda, V = CVR_vi, random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), R = list(spp_name_phylo=phylo_vcv), control=list(optimizer="optim"), test = "t", data = data)
SMD <- metafor::rma.mv(SMD_yi_flip ~ -1 + personality_trait + sqrt_inv_n_tilda, V = SMD_vi, random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), R = list(spp_name_phylo=phylo_vcv), test = "t", data = data)
return(list(SMD = SMD,
lnCVR = lnCVR))
}
MLMR_models_pers_pubbias <- meta_model_fits(pers_new, phylo_vcv, type = "pubbias")
# Extract the SMD and lnCVR results
smd_mods_pubbias <- MLMR_models_pers_pubbias["SMD",]
lnCVR_mods_pubbias <- MLMR_models_pers_pubbias["lnCVR",]
smd_mods_pubbias <- MLMR_models_pers_pubbias["SMD",]
smd_mods_pubbias
lnCVR_mods_pubbias
saveRDS(MLMR_models_pers_pubbias, "./output/MLMR_models_pers_pubbias")
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
# Install CRAN packages
library("pacman")
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
# Install orchard plot and metaAidR packages from GitHub
devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE);
devtools::install_github("daniel1noble/metaAidR");
pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot, stringr)
setwd("~/Documents/GitHub/sex_meta/")
# Source our own functions
source("./R/func.R")
pers_new <- read.csv("./data/pers_new.csv", stringsAsFactors = FALSE)
# Find all tree file names
tree_files <- paste0("./trees/", list.files("./trees"))[-1]
# Bird tree has been constructed already, just need to get trees for the rest of the taxo groups
trees <- lapply(tree_files, function(x) read.tree(x))
names <- gsub("~./trees/", "", tree_files)
names(trees) <- names
# Plot the trees and see how they look
par(mfrow = c(1,5), mar = c(1,1,1,1))
lapply(trees, function(x) plot(x, cex = 1))
# Check that they are ultrametric
lapply(trees, function(x) is.ultrametric(x))
# Check that all names in the phylogeny are also in the data
taxa_data_list <- split(pers_new, pers_new$taxo_group)
other_groups <- mapply(x = taxa_data_list,
y = trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
# Print out each taxon group
for(i in colnames(other_groups)){
print(i)
print(other_groups[,i] )
}
# Now to prune trees so that we get tree names that match with species in data
pruned_trees <- mapply(x = taxa_data_list,
y = trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "prune"))
# Check that this has been done correctly
re_checks <- mapply(x = taxa_data_list,
y = pruned_trees,
function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
for(i in colnames(re_checks)){
print(i)
print(re_checks[,i] )
}
# Extract the phylogenetic correlation matrices
phylo_vcv <- lapply(pruned_trees, function(x) vcv(x, corr = TRUE)) # these matrices are used in the meta-a models
# calculating the inverse of the 'effective sample size' to account for unbalanced sampling
pers_new$inv_n_tilda <- with(pers_new, ((female_n + male_n)/(female_n*male_n)))
pers_new$sqrt_inv_n_tilda <- with(pers_new, (sqrt(inv_n_tilda))) # use this first, if significant, then use the 1st one
MLMR_models_pers_pubbias <- meta_model_fits(pers_new, phylo_vcv, type = "pubbias")
# Extract the SMD and lnCVR results
smd_mods_pubbias <- MLMR_models_pers_pubbias["SMD",]
lnCVR_mods_pubbias <- MLMR_models_pers_pubbias["lnCVR",]
smd_mods_pubbias
lnCVR_mods_pubbias
saveRDS(MLMR_models_pers_pubbias, "./output/MLMR_models_pers_pubbias")
