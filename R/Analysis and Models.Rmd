---
title: "Data Analysis and Meta-A Models"
author: "Lauren Harrison"
date: "28/02/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Load packages
```{r}
# Clear work space
  rm(list=ls())

# Install CRAN packages
  install.packages("pacman")

# Install orchard plot package
  devtools::install_github("itchyshin/orchard_plot", subdir = "orchaRd", force = TRUE, build_vignettes = TRUE); 
  devtools::install_github("daniel1noble/metaAidR"); 

  pacman::p_load(knitr, metafor, dplyr, kableExtra, tidyverse, rotl, phytools, GGally, R.rsp, patchwork, devtools, robumeta, ape, geiger, phytools, phangorn, rlist, orchaRd, metaAidR, corrplot)

# Source our own functions
  source("./R/func.R")

# Set the rerun object to FALSE so that you don't need to re-run all models again. Some take quite a lot of time to run. If FALSE, it will just re-load them. If you need to re-run, then simply just change to TRUE
rerun_models = FALSE
```

# 2. Load datasets
```{r}
    pers <- read.csv("./data/pers_data.csv", stringsAsFactors = FALSE)
bodysize <- read.csv("./data/bodysize_SSD.csv", stringsAsFactors = FALSE)

```

# 3. Fix "pers" dataset before we get started
```{r}

# check for differences between pers and bodysize "species names" columns before joining them
  #setdiff(bodysize$species_name, pers$species_name) 
      #Archocentrus nigrofasciatus is in body size but not pers - is now Amatitlania nigrofasciata which is it's own entry

# Merge spp_names columns
  pers <- merge(x = pers,
                y = bodysize[,c("species_name", "SSD_index", "mating_system")],
                by="species_name", all.x=TRUE,  no.dups = TRUE)
  
# Just select the relevant columns for now to make life easier
  pers_new <- pers %>% 
          select(study_ID, year, species_name, SSD_index, taxo_group, data_type, personality_trait, male_n, male_mean, m_SE_to_SD, female_n, female_mean, f_SE_to_SD, depend, directionality, spp_name_phylo, mating_system, age, population, study_environment, study_type)

# Check out some outliers
#  pers_new %>%
#  filter(is.na(SSD_index))

# Check species numbers
  pers_new %>%
  group_by(taxo_group) %>%
  summarise(species = length(unique(species_name)))

# Add in observation level random effect
  pers_new <- pers_new %>% 
            group_by(taxo_group) %>% 
            mutate(obs = 1:length(study_ID))
  
# NOTE FOR LAUREN save prepared pers_new dataset as output to save time :)
```

# 4. Calculate effect sizes (SMD and lnCVR)
```{r}
# calculating effect sizes

# SMD (Hedge's g)
  pers_new <- escalc(measure = "SMD", 
                n1i = male_n, n2i = female_n,
                m1i = male_mean, m2i = female_mean,
                sd1i = m_SE_to_SD, sd2i = f_SE_to_SD, data = pers_new, var.names=c("SMD_yi","SMD_vi"), append = TRUE)

# lnCVR
  pers_new <- escalc(measure = "CVR",
                       n2i = female_n, n1i = male_n,
                       m2i = female_mean, m1i = male_mean,
                       sd2i = f_SE_to_SD, sd1i = m_SE_to_SD, data = pers_new, var.names=c("CVR_yi","CVR_vi"))

# Find out why we have na? Seems like this is because SD in one of the sexes is zero. We could add a very small number here or assume 0 is NA and impute, but I would just exclude.
  #spp_drop <- pers_new %>%
  #filter(is.na(CVR_yi))

  #as.character(unique(spp_drop$spp_name_phylo))

# Exclude NAs
  pers_new <- pers_new %>%
              filter(!is.na(CVR_yi), !is.na(SMD_yi))
  dim(pers_new)            
```

# Plot effect sizes to see how they look
```{r}
# lnCVR
  hist(pers_new$CVR_yi)
  funnel(x = pers_new$CVR_yi, vi = pers_new$CVR_vi, yaxis="seinv", xlim = c(-10, 10))

#SMD
  hist(pers_new$SMD_yi)
  funnel(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, yaxis="seinv")
  text(as.character(pers_new$study_ID), x = pers_new$SMD_yi, y = 1/sqrt(pers_new$SMD_vi))

# Effect sizes 3 and above
  pers_new %>%
  filter(SMD_yi > 3)
  
# Effect sizes below -5
  pers_new %>% 
  filter(SMD_yi < -5)
# checking SMD outliers
  # P038 is correct as reported in paper, but is a proportion
  # P029 has male SD wrong - paper says 64.4 but was recorded as 0.001 for some reason - amended in pers dataset
  # P017 is correct
  # P021 looks weird in paper too but is correct
  # P136 is correct
  # P014 is correct
  # P029 male error looks too small
  # P165 is a boldness score
  # P015 6 effect sizes are proportions, the rest change direction (check figures though)
  # P003 both effect sizes are aggression scores
  

#NOTE Lauren. Can you also check all the data on the top of the funnels. For some analyses the ratio of smallest to largest sampling variance is very large. This could be problems with data that have very high precision, could be incorrect sample sizes, SD or SE entered wrong. For example, check all data where Inverse SE > 14 in funnel for SMD and > 17 for lnCVR.  
  
# checking SMD outliers - inverse SE > 14
funnel(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, yaxis="seinv")
 text(as.character(pers_new$obs), x = pers_new$SMD_yi, y = 1/sqrt(pers_new$SMD_vi), offset = 0.8)
 
# outliers (SMD):
    # obs 509 (-23 for SMD) - in P015 and is correct/ genuine strong difference
    # obs 128 (27.87 inverse SE) - in P041: is a score for aggression, but looks correct
    # obs 120 (also high inverse SE) - in P091: looks correct, females have more variation than males, but same means
    # obs 41 (big SMD difference, low error) - in P017: is correct, males were active for much longer than females (check error)
    # obs 42 (big SMD difference, low error) - in P017: is correct, males were active for much longer than females (check error)
    # obs 136 (big SMD, high error?) - in P165: SCORE - big sample size, precise data
    # obs 121 (no mean diff, small error) - in P041: SCORE - big sample size, big SD
    # obs 301 (no mean diff, small error) - in P211: exploration time, big sample sizes so high precision?
    # obs 603 (no mean diff, small error) - in P097 or P157?

# checking lnCVR outliers
 funnel(x = pers_new$CVR_yi, vi = pers_new$CVR_vi, yaxis="seinv", xlim = c(-10, 10))
 text(as.character(pers_new$obs), x = pers_new$CVR_yi, y = 1/sqrt(pers_new$CVR_vi), offset = 0.8) 
  
# outliers (lnCVR):
    # obs 120 - in P041? - really big sample size, small error (so precise?)
    # obs 128 - in P041 - aggression SCORE, again big sample size and small error
    # obs 124 - in P041 - same thing
    # obs 121 - also in P041
    # obs 136 - in P165 - score, males and females have the same error from a really big sample size (check this one out)
 
```

### NEED TO DO BEFORE RUNNING PROPER MODELS ### 
1. Need to transform proportions to logits, then to Hedge's g?  
2. Scores - cut them out? 
    See section 10 for these two points
3. Flip signs where indicated 
    Done

# Lets flip signs of effects for SMD
The directional meaning of effect sizes vary depending on the specific units and trait being measured. The data has a directionality column that tells one if the meaning should be reversed (1) or left the same. 

```{r}
   pers_new$directionality <- ifelse(is.na(pers_new$directionality), 0, 1)

      pers_new$SMD_yi_flip <- ifelse(pers_new$directionality == 1, pers_new$SMD_yi*(-1), pers_new$SMD_yi)
```
# Prepare the phylogenic trees
For each taxonomic group the phylogenetic trees have been constructed. We'll use these trees for multi-level meta-analytic models throughout. 

```{r}
    
    # Find all tree file names
    tree_files <- paste0("./trees/", list.files("./trees"))[-1]

    # Read in bird trees (100) and take the average tree as consensus tree. Only need to do this once, and then re-write the file to make things easier. Note that here we are just writing the consensus tree
        #tree_bird <- read_birds(tree_files[1])
        #write.tree(tree_bird, "bird_species.nwk")
    
    # Get the rest of the taxa    
      trees <- lapply(tree_files, function(x) read.tree(x))
      names <- gsub("./trees/", "", tree_files)
      names(trees) <- names

    # Plot the trees and see how they look
      par(mfrow = c(1,5), mar = c(1,1,1,1))
      lapply(trees, function(x) plot(x, cex = 1))

    # Check that they are ultrametric
      lapply(trees, function(x) is.ultrametric(x))

    # Check that all names in the phylogeny are also in the data
      taxa_data_list <- split(pers_new, pers_new$taxo_group)
      
      other_groups <- mapply(x = taxa_data_list, 
                             y = trees, 
                             function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))

          #Print out each taxon group
      for(i in colnames(other_groups)){
            print(i)
            print(other_groups[,i] )
      }
      

      # Now we are ready to prune trees so that we get tree names match with species in data
      pruned_trees <- mapply(x = taxa_data_list, 
                             y = trees, 
                             function(x,y) tree_checks(x,y, "spp_name_phylo", type = "prune"))

      # Check that this has been done correctly
        re_checks <- mapply(x = taxa_data_list, 
                             y = pruned_trees, 
                             function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))
        
      for(i in colnames(re_checks)){
            print(i)
            print(re_checks[,i] )
      }

    # Extract the phylogenetic correlation matrices
            phylo_vcv <- lapply(pruned_trees, function(x) vcv(x, corr = TRUE))

```

# 5. models
Let's run the first bunch of models on the whole dataset. We'll start off with intercept only multi-level meta-analytic models, then move to multi-level meta-regression models. The functions in `func.R` should be consulted to see precisely what models are being fit across the taxonomic groups

```{r}
# Now we can fit some models. First our MLMA intercept only models, across each taxa. 

#NOTE Lauren: There are some issues with lnCVR models. Ratio of sampling variances are very large, probably because of outliers. I suggest removing outliers and checking model results don't change.

  if(rerun_models == TRUE){
    MLMA_models <- meta_model_fits(pers_new, phylo_vcv, type = "int")
    saveRDS(MLMA_models, "./output/MLMA_models_int")
  }else{
    MLMA_models <- readRDS("./output/MLMA_models_int")
  }


# View model results. Warning messages exist because there are NA values for lnCVR. These can be removed from the data. We can also get from these models estimates of heterogeneity from our models. Here we need the sampling variance vector and also the models for SMD and CVR. We can then use multivariate apply (mapply) across these lists

  split_taxa <- split(pers_new, pers_new$taxo_group)
    smd_mods <- MLMA_models["SMD",]
  lnCVR_mods <- MLMA_models["lnCVR",]

# From these models we can get I2 estimates. I'll show an example with birds. study_ID is the between study heterogeneity. Just pay attention to the "phylo", that tells if there is a phylogenetic signal and the strength of that signal. Total I2 is testing how much heterogeneity you have beyond sampling variance.
  birds_smd = I2(smd_mods[[1]], v = split_taxa[[1]]$SMD_vi, phylo = "spp_name_phylo")
  birds_CVR = I2(lnCVR_mods[[1]], v = split_taxa[[1]]$CVR_vi, phylo = "spp_name_phylo")
  
# Finding I2 for the remaining species.
  fish_smd = I2(smd_mods[[2]], v = split_taxa[[2]]$SMD_vi, phylo = "spp_name_phylo")
  fish_CVR = I2(lnCVR_mods[[2]], v = split_taxa[[2]]$CVR_vi, phylo = "spp_name_phylo")
  invert_smd = I2(smd_mods[[3]], v = split_taxa[[3]]$SMD_vi, phylo = "spp_name_phylo")
  invert_CVR = I2(lnCVR_mods[[3]], v = split_taxa[[3]]$CVR_vi, phylo = "spp_name_phylo")
  mammal_smd = I2(smd_mods[[4]], v = split_taxa[[4]]$SMD_vi, phylo = "spp_name_phylo")
  mammal_CVR = I2(lnCVR_mods[[4]], v = split_taxa[[4]]$CVR_vi, phylo = "spp_name_phylo")
  reptile_smd = I2(smd_mods[[5]], v = split_taxa[[5]]$SMD_vi, phylo = "spp_name_phylo")
  reptile_CVR = I2(lnCVR_mods[[5]], v = split_taxa[[5]]$CVR_vi, phylo = "spp_name_phylo")
  
# Now that we have our list of models, we can extract the estimates, CIs and even prediction intervals. Use our new orchaRd package to do this. 

  MLMA_estimates_SMD <- plyr::ldply(lapply(smd_mods, function(x) print(mod_results(x, mod = "Int"))))
  MLMA_estimates_lnCVR <- plyr::ldply(lapply(lnCVR_mods, function(x) print(mod_results(x, mod = "Int"))))

```

# 6. Run random effects models for each of the personality traits separately, and for each of the taxonomic groups?
```{r}
# OK, now we can have a look at a sensible model that looks at moderators. We'll look first at the personality trait moderator. Note, we'll estimate the mean for each of the categorical levels because we are not so much interested in whether the means differ, but whether or not males and females differ in any of these traits

  if(rerun_models == TRUE){
      MLMR_models_pers_trait <- meta_model_fits(pers_new, phylo_vcv, type = "pers")
      saveRDS(MLMR_models_pers_trait, "./output/MLMR_models_pers_trait")
    } else{
      MLMR_models_pers_trait <- readRDS("./output/MLMR_models_pers_trait")
    }
# Extract the SMD and lnCVR results
    smd_mods_pers <- MLMR_models_pers_trait["SMD",]
  lnCVR_mods_pers <- MLMR_models_pers_trait["lnCVR",]

# Get the combined estimates from them all
   MLMA_estimates_SMD_pers <- plyr::ldply(lapply(smd_mods_pers, function(x) print(mod_results(x, mod = "personality_trait"))))
 MLMA_estimates_lnCVR_pers <- plyr::ldply(lapply(lnCVR_mods_pers, function(x) print(mod_results(x, mod = "personality_trait"))))

 # You probably want to add in n and k to these dataframes
  n_k<- pers_new %>%
      group_by(taxo_group, personality_trait) %>%
      summarise(n = n(), spp = length(unique(spp_name_phylo)), k = length(unique(study_ID)))

  MLMA_estimates_SMD_pers <- data.frame(MLMA_estimates_SMD_pers, n_k[,c("n", "spp", "k")])
  MLMA_estimates_lnCVR_pers <- data.frame(MLMA_estimates_lnCVR_pers, n_k[,c("n", "spp", "k")])

```

# 7. Now have a look at how SSD interacting with personality trait type. Here we are not estimating a intercept either, so each intercept varies by trait category and each slope as well. Note that there are lots of warnings, but these are the result of many levels not being present in taxa groups. Note also here that the SSD_index is scaled to make the interpretation of the intercepts a little more sensible

```{r}

# remove NAs from SSD data before running the model
# Exclude NAs
  pers_new <- pers_new %>%
              filter(!is.na(SSD_index))
  dim(pers_new)    
  
# plot SSD distribution in each taxo group for each pers trait to get an idea of spread
  ggplot(pers_new, aes(x=taxo_group, y=SSD_index, fill=personality_trait)) + geom_boxplot()
  
# flip SSD index so males > females = positive value instead of males < females = positive
# pers_new$SSD_index_flip <- pers_new$SSD_index*(-1) - this makes females the positive value when larger, so ignore this
  
if(rerun_models == TRUE){
      MLMR_models_pers_SSD <- meta_model_fits(pers_new, phylo_vcv, type = "pers_SSD")
      saveRDS(MLMR_models_pers_SSD, "./output/MLMR_models_pers_SSD")
    } else{
      MLMR_models_pers_SSD <- readRDS("./output/MLMR_models_pers_SSD")
    }

# Extract the SMD and lnCVR results
    smd_mods_pers_SSD <- MLMR_models_pers_SSD["SMD",]
  lnCVR_mods_pers_SSD <- MLMR_models_pers_SSD["lnCVR",]

# NOTE: Lauren you'll need to write a function to extract estimates here as the mod_results from OrchaRd only works with a single categorical moderator. Or, you can manually extract, but I don't recommend.
  
  # can use Dan's function here to extract estimates - just have to tweak it a little bit
  
# A crude way to see no. unique species, no. unique studies and no. SSD values for each taxo group and for each pers trait in these models
data.frame(pers_new %>%
group_by(taxo_group, personality_trait) %>%
filter(!is.na(SSD_index))%>%
summarise(N_ssd = length(SSD_index), N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))

# adjusted models used for SSD:
  # SSD (not scaled), no interaction term
    lnCVR <- metafor::rma.mv(CVR_yi ~ -1+ personality_trait + SSD_index, V = CVR_vi, random = list(~1|study_ID, random~1|spp_name_phylo, ~1|obs), R = list(spp_name_phylo=phylo_vcv), test = "t", data = data)

    SMD <- metafor::rma.mv(SMD_yi_flip ~ -1 + personality_trait + SSD_index, V = SMD_vi, random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), R = list(spp_name_phylo=phylo_vcv), test = "t", data = data)

  # interaction models with optimiser changed for convergence
              lnCVR <- metafor::rma.mv(CVR_yi ~ -1+ personality_trait*SSD_index, V = CVR_vi, random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), R = list(spp_name_phylo=phylo_vcv), control=list(optimizer="optim"), test = "t", data = data)

            SMD <- metafor::rma.mv(SMD_yi_flip ~ -1 + personality_trait*SSD_index, V = SMD_vi, random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), R = list(spp_name_phylo=phylo_vcv), control=list(optimizer="optim"), test = "t", data = data) 

```

# NOTE: Since we are conducting our meta-regression at the species level (the level at which we can assume effect sizes are independent), any personality trait with fewer than 10 species needs to be dropped to look at interactions between SSD and personality. Having a minimum of 10 studies etc. is the rule of thumb for meta-regressions (e.g. see Borenstein et al Intro to Meta-A)

```{r}
# NEED TO DROP: 
#   ALL REPTILES - GONE
#   BIRDS - EVERYTHING BUT BOLDNESS - DONE
#   FISH - ACTIVITY, EXPLORATION & SOCIALITY - DONE
#   INVERTS - SOCIALITY, EXPLORATION & AGGRESSION - DONE
#   MAMMALS - SOCIALITY - DONE

# 1. MAMMALS

# First, we need to subset our pers dataset by taxo group to drop the unwanted levels. Let's start with mammals because it's the easiest one
    pers_new_mammal <- as.data.frame(pers_new %>%
    filter(!personality_trait == "sociality" & taxo_group == "mammal"))

  # Check that this has been done correctly
      pers_new_mammal %>%
      group_by(personality_trait) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  

# Extract the phylogenetic correlation matrices
  phylo_vcv_mammal <- phylo_vcv[[4]] # seems to work better than the crap I just went through

# Rerun SSD model with interaction term:
#SMD
  MLMR_mods_pers_SSD_mammal_SMD <- rma.mv(SMD_yi_flip ~ -1 + personality_trait*scale(SSD_index), V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_mammal), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_mammal)

#lnCVR
  MLMR_mods_pers_SSD_mammal_lncvr <- rma.mv(CVR_yi ~ -1+ personality_trait*scale(SSD_index), V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_mammal), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_mammal)
  
# 2. BIRDS

  # subset dataset
  pers_new_bird <- as.data.frame(pers_new %>%
    filter(personality_trait == "boldness" & taxo_group == "bird"))

  # Check that this has been done correctly
      pers_new_bird %>%
      group_by(personality_trait) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))) 

  # phylo_vcv - let's just see if we can use the same tree like with mammals
  phylo_vcv_bird <- phylo_vcv[[1]]
  
  # rerun models
#SMD
  MLMR_mods_pers_SSD_bird_SMD <- rma.mv(SMD_yi_flip ~ scale(SSD_index), V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_bird), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_bird)

#lnCVR
  MLMR_mods_pers_SSD_bird_lncvr <- rma.mv(CVR_yi ~ scale(SSD_index), V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_bird), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_bird)
  
# 3. FISH
  # subset dataset
  pers_new_fish <- as.data.frame(pers_new %>%
   filter(personality_trait == "boldness" | personality_trait == "aggression") %>%
  filter(taxo_group == "fish")) 
    
  # Check that this has been done correctly
      pers_new_fish %>%
      group_by(personality_trait) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  
  
  # phylo
  phylo_vcv_fish <- phylo_vcv[[2]]
  
  # rerun models
#SMD
  MLMR_mods_pers_SSD_fish_SMD <- rma.mv(SMD_yi_flip ~ -1 + personality_trait*SSD_index, V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_fish), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_fish)

#lnCVR
  MLMR_mods_pers_SSD_fish_lncvr <- rma.mv(CVR_yi ~ -1 + personality_trait*SSD_index, V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_fish), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_fish)

# 4. INVERTS
  # subset dataset
  pers_new_invert <- as.data.frame(pers_new %>%
   filter(personality_trait == "activity" | personality_trait == "boldness") %>%
  filter(taxo_group == "invertebrate")) 
    
  # Check that this has been done correctly
      pers_new_invert %>%
      group_by(personality_trait) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  
  
  # phylo
  phylo_vcv_invert <- phylo_vcv[[3]]
  
  # rerun models
#SMD
  MLMR_mods_pers_SSD_invert_SMD <- rma.mv(SMD_yi_flip ~ -1 + personality_trait*scale(SSD_index), V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_invert), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_invert)

#lnCVR
  MLMR_mods_pers_SSD_fish_lncvr <- rma.mv(CVR_yi ~ -1 + personality_trait*scale(SSD_index), V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_invert), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_invert)  
```

# 8. mating system - retrying this model because I think that this might be an important moderator term to look at sexual selection over natural selection (which I think SSD encompasses both)

```{r}
# remove NAs from data before running the model
# Exclude NAs
  pers_new <- pers_new %>%
              filter(!is.na(mating_system))
  dim(pers_new) 
  
# what have we got to work with - do we need to combine multiple mating systems into 1 category?
    pers_new %>%
    group_by(taxo_group, personality_trait, mating_system) %>%
    summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  
    
# combine multiple mating systems into 1 category - multiple mating because most pers levels don't have enough data for comparison with the current split
    #doing it by hand because coding it is so hard! 
    # birds and boldness only one with enough data

# check how much I can compare overall mean differences
pers_new %>%
    group_by(taxo_group, mating_system) %>%
    summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))) 
    # probably only have enough data for birds 

# First let's run the model with mating system and overall personality means/variability just to check

MLMR_models_pers_mating_system <- meta_model_fits(pers_new, phylo_vcv, type = "pers_mate")

# Extract the SMD and lnCVR results
    smd_mods_mating_system <- MLMR_models_pers_mating_system["SMD",]
  lnCVR_mods_mating_system <- MLMR_models_pers_mating_system["lnCVR",]

# Second, we can look at how mating system moderates boldness in birds - the one group we have enough data for
   # subset dataset
  pers_new_bird_bold <- as.data.frame(pers_new %>%
    filter(personality_trait == "boldness" & taxo_group == "bird"))
  
  # Check that this has been done correctly
      pers_new_bird_bold %>%
      group_by(mating_system) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))) 

  # phylo_vcv - let's just see if we can use the same tree like with mammals
     phylo_vcv_bird <- phylo_vcv[[1]]
  
  # run the models 
#SMD
  MLMR_mods_pers_mate_bird_SMD <- rma.mv(SMD_yi_flip ~ mating_system -1, V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_bird), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_bird_bold)

#lnCVR
  MLMR_mods_pers_mate_bird_lncvr <- rma.mv(CVR_yi ~ mating_system -1, V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_bird), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_bird_bold)
```

# 9. parental care - models weren't very informative/lacked data/difficult to run so these have been removed from analysis 

## 10. Secondary Models
These additional models are just looking at a bunch of moderator terms likely to contribute to sex differences (i.e. environment under which the behaviours were studied). 

# 10a. Secondary model 1 - Age
Also recorded whether individuals were adults or juveniles (not sexually mature). Since we might expect that sex differences in behaviours (particularly behaviours related to mate choice or mating success) would manifest once individuals are sexually mature, it would probably be a good idea to see if age moderates sex differences in personalities. Let's have a look at this in a secondary model with age as a moderator:

```{r}
# Let's see what we have to work with
data.frame(pers_new %>%
group_by(taxo_group, age) %>%
summarise(n= n(), N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))

# model:
 MLMR_models_pers_age <- meta_model_fits(pers_new, phylo_vcv, type = "age")

# Extract the SMD and lnCVR results
  smd_mods_pers_age <- MLMR_models_pers_age["SMD",]
  lnCVR_mods_pers_age <- MLMR_models_pers_age["lnCVR",]
  
```

# 10b. Secondary model 2 - Population
Where the study animal population was from - wild-caught individuals or lab-reared? Might have more of an effect on lnCVR than SMD...

```{r}
# Let's see what we have to work with
data.frame(pers_new %>%
group_by(taxo_group, population) %>%
summarise(n = n(), N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))

# model:
 MLMR_models_pers_pop <- meta_model_fits(pers_new, phylo_vcv, type = "pop")

# Extract the SMD and lnCVR results
  smd_mods_pers_pop <- MLMR_models_pers_pop["SMD",]
  lnCVR_mods_pers_pop <- MLMR_models_pers_pop["lnCVR",]
  
# how to swap the levels and compare them???
```

# 10c. Secondary model 3 - Study Environment
Does the environment where studies were conducted moderate personality differences between the sexes?

```{r}
# Let's see what we have to work with
data.frame(pers_new %>%
group_by(taxo_group, study_environment) %>%
summarise(n = n(), N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))

# model:
 MLMR_models_pers_environ <- meta_model_fits(pers_new, phylo_vcv, type = "environ")

# Extract the SMD and lnCVR results
  smd_mods_pers_enviro <- MLMR_models_pers_environ["SMD",]
  lnCVR_mods_pers_enviro <- MLMR_models_pers_environ["lnCVR",]
  
# how to swap the levels and compare them???
```

# 10d. Secondary model 4 - Study type
Does the type of experimental manipulation (observation or manipulation) moderate personality differences between the sexes?

```{r}
# Let's see what we have to work with
data.frame(pers_new %>%
group_by(taxo_group, study_type) %>%
summarise(N_spp = length(unique(spp_name_phylo)), N_studies = length(unique(study_ID))))
    # data is a bit sparse here, so let's just look at how study type moderates personality overall, not within each test
    # inverts only have experimental observations, so need to exclude inverts from this analysis
    # because our phylo_vcv matrix is in a list that is hard to drop elements from, let's just run each model individually like we did for SSD interactions

# 1. MAMMALS

# Subset data
    pers_new_mammal <- as.data.frame(pers_new %>%
    filter(taxo_group == "mammal"))

  # Check that this has been done correctly
      pers_new_mammal %>%
      group_by(study_type) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  

# Extract the phylogenetic correlation matrices
  phylo_vcv_mammal <- phylo_vcv[[4]] # seems to work better than the crap I just went through

# Run models with just study type as moderator:
#SMD
  MLMR_mods_pers_studytype_mammal_SMD <- rma.mv(SMD_yi_flip ~ study_type - 1, V = SMD_vi, 
                                                   random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                                   R = list(spp_name_phylo=phylo_vcv_mammal), control=list(optimizer="optim"), 
                                                   test = "t", data = pers_new_mammal)

#lnCVR
MLMR_mods_pers_studytype_mammal_lncvr <- rma.mv(CVR_yi ~ study_type - 1, V = CVR_vi, 
                                                   random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                                   R = list(spp_name_phylo=phylo_vcv_mammal), control=list(optimizer="optim"), 
                                                   test = "t", data = pers_new_mammal)

# 2. BIRDS

  # subset dataset
  pers_new_bird <- as.data.frame(pers_new %>%
    filter(taxo_group == "bird"))

  # Check that this has been done correctly
      pers_new_bird %>%
      group_by(study_type) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo))) 

  # phylo_vcv - let's just see if we can use the same tree like with mammals
  phylo_vcv_bird <- phylo_vcv[[1]]
  
  # rerun models
#SMD
  MLMR_mods_pers_studytype_bird_SMD <- rma.mv(SMD_yi_flip ~ study_type - 1, V = SMD_vi, 
                                                   random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                                   R = list(spp_name_phylo=phylo_vcv_bird), control=list(optimizer="optim"), 
                                                   test = "t", data = pers_new_bird)

#lnCVR
MLMR_mods_pers_studytype_bird_lncvr <- rma.mv(CVR_yi ~ study_type - 1, V = CVR_vi, 
                                                   random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                                   R = list(spp_name_phylo=phylo_vcv_bird), control=list(optimizer="optim"), 
                                                   test = "t", data = pers_new_bird)
  
# 3. FISH
  # subset dataset
  pers_new_fish <- as.data.frame(pers_new %>%
  filter(taxo_group == "fish")) 
    
  # Check that this has been done correctly
      pers_new_fish %>%
      group_by(study_type) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  
  
  # phylo
  phylo_vcv_fish <- phylo_vcv[[2]]
  
  # rerun models
#SMD
  MLMR_mods_pers_studytype_fish_SMD <- rma.mv(SMD_yi_flip ~ study_type -1, V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_fish), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_fish)

#lnCVR
  MLMR_mods_pers_SSD_fish_lncvr <- rma.mv(CVR_yi ~ study_type -1, V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_fish), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_fish)

# 4. Reptiles
  # subset dataset
  pers_new_reptile <- as.data.frame(pers_new %>%
  filter(taxo_group == "reptilia")) 
    
  # Check that this has been done correctly
      pers_new_reptile %>%
      group_by(study_type) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  
  
  # phylo
  phylo_vcv_reptile <- phylo_vcv[[5]]
  
  # rerun models
#SMD
  MLMR_mods_pers_studytype_rep_SMD <- rma.mv(SMD_yi_flip ~ study_type -1, V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_reptile), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_reptile)

#lnCVR
  MLMR_mods_pers_SSD_rep_lncvr <- rma.mv(CVR_yi ~ study_type -1, V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_reptile), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_reptile)

  # subset dataset
  pers_new_study_type <- as.data.frame(pers_new %>%
  filter(!taxo_group == "invertebrate")) 
  
  # check this has been done correctly
      pers_new_study_type %>%
      group_by(taxo_group, personality_trait) %>%
      summarise(n = n(), studies = length(unique(study_ID)), species = length(unique(spp_name_phylo)))  
  
  # phylo
  phylo_vcv_study_type <- phylo_vcv[[]]
  
  # rerun models
#SMD
  MLMR_mods_pers_SSD_invert_SMD <- rma.mv(SMD_yi_flip ~ -1 + personality_trait*scale(SSD_index), V = SMD_vi, 
                                          random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                          R = list(spp_name_phylo=phylo_vcv_invert), control=list(optimizer="optim"), 
                                          test = "t", data = pers_new_invert)

#lnCVR
  MLMR_mods_pers_SSD_fish_lncvr <- rma.mv(CVR_yi ~ -1 + personality_trait*scale(SSD_index), V = CVR_vi, 
                                            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
                                            R = list(spp_name_phylo=phylo_vcv_invert), control=list(optimizer="optim"), 
                                            test = "t", data = pers_new_invert)    


```

# 11. TO DO Sensitivity Analyses: 

1) We need to refit these models accounting for any dependency resulting from the same traits measured on the same animals (likely a big one) and any other shared covariance. Probably this is best added to the residual variance matrix as opposed to the sampling covariance. 
2) Need to test if there are differences between proportion data; include moderator in a simple model. 
3) Need to test if there are differences between score data; include moderator in a simple model. 

```{r}
 # Create the dependency matrices; try 3 levels of rho = 0.3, 0.5, 0.8
      
      pers_new <- data.frame(pers_new %>%
      group_by(taxo_group) %>%
      mutate(depend_n = paste0(study_ID, "_", depend)))
    
      split_taxa <- split(pers_new, pers_new$taxo_group)
    
# 0.3 rho:
  D_matrices_0.3 <- lapply(split_taxa, function(x) make_VCV_matrix(x, V = x$SMD_vi, cluster = "depend_n", obs = "obs", type = "cor", rho = 0.3))
# 0.5 rho:
   D_matrices_0.5 <- lapply(split_taxa, function(x) make_VCV_matrix(x, V = x$SMD_vi, cluster = "depend_n", obs = "obs", type = "cor", rho = 0.5))
# 0.8 rho:   
    D_matrices_0.8 <- lapply(split_taxa, function(x) make_VCV_matrix(x, V = x$SMD_vi, cluster = "depend_n", obs = "obs", type = "cor", rho = 0.8))
  
  # NOTE: Lauren –Have a look and make sure these matrices are correct. You should see correlations for numbers within studies that match. Usually these are blocks of effects along the diagonal. IF you have ones far away form the signal, then you need to check these. Here is an example with reptiles
    corrplot(D_matrices_0.3[[5]], tl.cex= 0.3) # Reptiles
    write.csv(D_matrices_0.3[[5]], "reptiles_D_0.3.csv") # Can write it and have a closer look too

    #Once happy with the D matrices you can refit models, but just modify as follows:

    fit_int_MLMAmodel_D <- function(data, phylo_vcv, D){

          lnCVR <- mapply(function(x,y,z) metafor::rma.mv(CVR_yi ~ 1, V = CVR_vi, 
            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
            R = list(spp_name_phylo=y, obs = z), 
            data = x), x = split_taxa, y = phylo_vcv, z = D_matrices_0.3)

            SMD <- metafor::rma.mv(SMD_yi_flip ~ 1, V = SMD_vi, 
              random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
              R = list(spp_name_phylo=phylo_vcv, obs = D), 
              data = data) 

          return(list(SMD = SMD, 
                lnCVR = lnCVR))
}

 lnCVR <- metafor::rma.mv(CVR_yi ~ 1, V = CVR_vi, 
            random = list(~1|study_ID, ~1|spp_name_phylo, ~1|obs), 
            R = list(spp_name_phylo=phylo_vcv[[5]], obs = D_matrices_0.3[[5]]), 
            data = split_taxa[[5]])


   fit_int_MLMAmodel_D(pers_new, phylo_vcv, D_matrices_0.3) # error - R not square matrix?
    
  # rewrite function to split model by taxa and give us the summary
  meta_model_fits_D <- function(data, phylo_vcv, D, type = c("int", "pers", "pers_SSD")){
         taxa_list <- split(data, data$taxo_group)

      type <-  match.arg(type)

    if(type == "int"){
        model_fits <- mapply(function(x, y) fit_int_MLMAmodel_D(x, y, D), x = taxa_list, y = phylo_vcv, D = )
    }

    if(type == "pers"){
        model_fits <- mapply(function(x, y) fit_MLMA_reg_models_personality_trait(x, y), x = taxa_list, y = phylo_vcv)
    }

  	if(type == "pers_SSD"){
        model_fits <- mapply(function(x,y) fit_MLMA_reg_models_personality_trait_SSD_index(x, y), x = taxa_list, y = phylo_vcv)
    }

   return(model_fits)
} 

# intercept models with rho = 0.5 
MLMA_models_D <- meta_model_fits_D(pers_new, phylo_vcv, D_matrices_0.5, type = "int") # object D is missing??

split_taxa <- split(pers_new, pers_new$taxo_group)
    smd_mods_D <- MLMA_models_D["SMD",]
  lnCVR_mods_D <- MLMA_models_D["lnCVR",]

  MLMA_estimates_SMD_D <- plyr::ldply(lapply(smd_mods_D, function(x) print(mod_results(x, mod = "Int")))) 
  MLMA_estimates_lnCVR_D <- plyr::ldply(lapply(lnCVR_mods_D, function(x) print(mod_results(x, mod = "Int"))))
  
# pers models with rho = 0.5
MLMR_models_pers_trait_D <- meta_model_fits_D(pers_new, phylo_vcv, D_matrices_0.5, type = "pers")

# Extract the SMD and lnCVR results
    smd_mods_pers_D <- MLMR_models_pers_trait_D["SMD",]
  lnCVR_mods_pers_D <- MLMR_models_pers_trait_D["lnCVR",]

# Get the combined estimates from them all
   MLMA_estimates_SMD_pers_D <- plyr::ldply(lapply(smd_mods_pers_D, function(x) print(mod_results(x, mod = "personality_trait"))))
 MLMA_estimates_lnCVR_pers_D <- plyr::ldply(lapply(lnCVR_mods_pers_D, function(x) print(mod_results(x, mod = "personality_trait"))))
 
# SSD models with rho = 0.5
 MLMR_models_pers_SSD_D <- meta_model_fits_D(pers_new, phylo_vcv, D_matrices_0.5, type = "pers_SSD")

 # Extract the SMD and lnCVR results
    smd_mods_pers_SSD_D <- MLMR_models_pers_SSD_D["SMD",]
  lnCVR_mods_pers_SSD_D <- MLMR_models_pers_SSD_D["lnCVR",]    
```

# removing outliers to check model robustness
```{r}
# we observed some outliers in the SMD and lnCVR dataset - let's try removing the following and checking the model results:
# outliers (SMD):
    # obs 509 (-23 for SMD) - in P015 and is correct/ genuine strong difference
    # obs 128 (27.87 inverse SE) - in P041: is a score for aggression, but looks correct
    # obs 120 (also high inverse SE) - in P091: looks correct, females have more variation than males, but same means
    # obs 41 (big SMD difference, low error) - in P017: is correct, males were active for much longer than females (check error)
    # obs 42 (big SMD difference, low error) - in P017: is correct, males were active for much longer than females (check error)
    # obs 136 (big SMD, high error?) - in P165: SCORE - big sample size, precise data
    # obs 121 (no mean diff, small error) - in P041: SCORE - big sample size, big SD
    # obs 301 (no mean diff, small error) - in P211: exploration time, big sample sizes so high precision?
    # obs 603 (no mean diff, small error) - in P097 or P157?
# more SMD outliers
  # P038 is correct as reported in paper, but is a proportion
  # P029 has male SD wrong - paper says 64.4 but was recorded as 0.001 for some reason - amended in pers dataset
  # P017 is correct
  # P021 looks weird in paper too but is correct
  # P136 is correct
  # P014 is correct
  # P029 male error looks too small
  # P165 is a boldness score
  # P015 6 effect sizes are proportions, the rest change direction (check figures though)
  # P003 both effect sizes are aggression scores
# outliers (lnCVR):
    # obs 120 - in P041? - really big sample size, small error (so precise?)
    # obs 128 - in P041 - aggression SCORE, again big sample size and small error
    # obs 124 - in P041 - same thing
    # obs 121 - also in P041
    # obs 136 - in P165 - score, males and females have the same error from a really big sample size (check this one out)

# let's try just removing all outliers that aren't scores or proportion first since we will be checking those too
 #pers_new_outliers <- as.data.frame(pers_new %>%
    #filter(!study_ID == "P029" | !study_ID == "P014" | !study_ID == "P136" | !study_ID == "P021" | !study_ID == "P017" 
           #| !study_ID == "P015" | !study_ID == "P091" | !study_ID == "P211"))
dim(pers_new_outliers) # didn't work
dim(pers_new)

# plot the funnel to see if it looks any better
funnel(x = pers_new_outliers$SMD_yi, vi = pers_new_outliers$SMD_vi, yaxis="seinv")
 text(as.character(pers_new_outliers$obs), x = pers_new_outliers$SMD_yi, y = 1/sqrt(pers_new_outliers$SMD_vi), offset = 0.8)
 # a lot of the outliers are scores and proportions, so we will deal with them later
 
# rerun intercept models first to check
      MLMR_models_pers_outliers <- meta_model_fits(pers_new_outliers, phylo_vcv, type = "int")

# Extract the SMD and lnCVR results
    smd_mods_outliers <- MLMR_models_pers_outliers["SMD",]
  lnCVR_mods_outliers <- MLMR_models_pers_outliers["lnCVR",]

```

# 12. Publication bias
We can use: 1) funnel plots to look for asymmetry across all effect sizes for both SMD and lnCVR, 2) Egger's test which performs a regression test on our funnel plots ... but maybe not useful when there is high heterogeneity NOT caused by publication bias (which I think is the case for our data), and 3) trim and fill method to estimate the number of missing effect sizes and uses the asymmetry to add more points and provide a revised overall mean.

see: http://environmentalcomputing.net/meta-analysis-2/ for more information about publication bias methods. 
```{r}
# 1. funnel plot for all our effect sizes?
  # looks for asymmetry in effect sizes - could be due to heterogeneity or publication bias
    # SMD:
    funnel(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, yaxis = "seinv")

    # lnCVR:
    funnel(x = pers_new$CVR_yi, vi = pers_new$CVR_vi, yaxis="seinv", xlim = c(-10, 10))

# 2. Egger's test - regression test
  # applies a regression test to the funnel plots to provide a z score and p-value for likelihood of publication bias
    # SMD:
    regtest(x = pers_new$SMD_yi, vi = pers_new$SMD_vi, model='rma') #significant, suggests pub. bias z= -2.79, p=0.005
      
    # lnCVR:
    regtest(x = pers_new$CVR_yi, vi = pers_new$CVR_vi, model='rma') #NS z= -0.03, p=0.97

# 3. Trim-and-fill
  # uses funnel asymmetry to add more points (randomly or in another manner) and provides a revised overall mean for models 
    # can I use this method?
```
 
# 13. Making plots
```{r}
# Use orchard plot package to generate plots for our intercept models:
# Birds SMD & lnCVR
orchard_plot(smd_mods[[1]], mod = "Int", xlab = "Standardised mean difference", transfm = "none")
orchard_plot(lnCVR_mods[[1]], mod = "Int", xlab = "log Coefficient of Variance (lnCVR)", transfm = "none")

# for plotting categorical moderators, like personality traits:
# Bird lnCVR
bird_lncvr <- orchard_plot(lnCVR_mods_pers[[1]], mod = "personality_trait", xlab = "log Coefficient of Variance (lnCVR)", alpha = 0.5, transfm = "none")
# Fish lnCVR
fish_lncvr <- orchard_plot(lnCVR_mods_pers[[2]], mod = "personality_trait", xlab = "log Coefficient of Variance (lnCVR)", alpha = 0.5, transfm = "none")
# Invert lnCVR
invert_lncvr<- orchard_plot(lnCVR_mods_pers[[3]], mod = "personality_trait", xlab = "log Coefficient of Variance (lnCVR)", alpha = 0.5, transfm = "none")
# Mammal lnCVR
mammal_lncvr <- orchard_plot(lnCVR_mods_pers[[4]], mod = "personality_trait", xlab = "log Coefficient of Variance (lnCVR)", alpha = 0.5, transfm = "none")
# Reptile lnCVR
reptile_lncvr <- orchard_plot(lnCVR_mods_pers[[5]], mod = "personality_trait", xlab = "log Coefficient of Variance (lnCVR)", alpha = 0.5, transfm = "none")

# try wrapping them using patchwork

# personality SMD
# Bird SMD
bird_SMD <- orchard_plot(smd_mods_pers[[1]], mod = "personality_trait", xlab = "Standardised mean difference", alpha = 0.5, transfm = "none")
# Fish lnCVR
fish_SMD <- orchard_plot(smd_mods_pers[[2]], mod = "personality_trait", xlab = "Standardised mean difference", alpha = 0.5, transfm = "none")
# Invert lnCVR
invert_SMD<- orchard_plot(smd_mods_pers[[3]], mod = "personality_trait", xlab = "Standardised mean difference", alpha = 0.5, transfm = "none")
# Mammal lnCVR
mammal_SMD <- orchard_plot(smd_mods_pers[[4]], mod = "personality_trait", xlab = "Standardised mean difference", alpha = 0.5, transfm = "none")
# Reptile lnCVR
reptile_SMD <- orchard_plot(smd_mods_pers[[5]], mod = "personality_trait", xlab = "Standardised mean difference", alpha = 0.5, transfm = "none")

# put them all together!
bird_SMD + bird_lncvr + fish_SMD + fish_lncvr + invert_SMD + invert_lncvr + mammal_SMD + mammal_lncvr + reptile_SMD + reptile_lncvr

```

# phylogenetic trees for figures
The plan is to make 5 phylogenetic trees for the 5 broad taxonomic groups and map SSD (male or female-biased), no. effect sizes and the proportion of those effect sizes that go into each of the 5 personality trait categories for each species (spp_name_phylo)

```{r}
# using ggtree to plot lots of complex data onto phylogenetic trees
# tree should be circular in shape with spp_name_phylo names at tips, tip node will be red or blue to reflect SSD (NA will be black?). Next, row with total no. effect sizes for each species, with a heatmap following that with 5 different blocks of colour to represent the 5 personality traits (presence/absence)

# see: https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html for more information about using ggtree

## Steps for successful trees

# step 1) set up dataset so that SSD is either male-biased, female-biased or none (NA) 
# step 2) make sure each spp name is not duplicated
# step 3) make a column for each species with n = total effect sizes
# step 4) make second dataframe with personality trait info for each species in tree (can possibly generate a heat map with no changes)
# step 5) subset datasets based on taxo group so I can make 5 different trees

# install ggtree using this method:
source("https://bioconductor.org/biocLite.R")
BiocManager::install(version = "3.8")
BiocInstaller::biocLite("ggtree") # won't run 

``` 

# step 1) set up dataset for basic tree structure
```{r}
  # since our data is a bit weird (some different species share phylo name in tree due to constraints, so we have 2 different SSD values for them) let's print a list of unique phylo names and input the rest gradually to build a new dataframe for our plots.
              
      spp_phylo_list <- list(unique(pers_new$spp_name_phylo))
      write.csv(spp_phylo_list, "spp_list_figs")
  
      # check no. effect sizes for each species in phylogeny     
  pers_new %>%
      group_by(spp_name_phylo, personality_trait) %>%
      summarise(n = n())    
  
  ## data is in figs_data.csv file for easy figure-making!
  figs_data <- read.csv("./data/figs_data.csv", stringsAsFactors = FALSE)
  
  # subset dataset to just have birds for now
 bird_data <- as.data.frame(figs_data %>%
    filter(taxo_group == "bird"))
  
  # make SSD a binary category so its either male or female biased for easy visualising
#pers_new$SSD_binary <- ifelse(pers_new$SSD_index>0, 1, 0) # male-biased = 1, female-biased = 0

```

# making the tree (birds first)

```{r}
# setting up the basic tree structure
  # load tree, set node colours
birdtree <- pruned_trees[1] # need to prune tree to match species in dataset
  
# Check that all names in the phylogeny are also in the data
      taxa_data_list <- split(pers_new, pers_new$taxo_group)
      
      other_groups <- mapply(x = taxa_data_list, 
                             y = trees, 
                             function(x,y) tree_checks(x,y, "spp_name_phylo", type = "checks"))

          #Print out each taxon group
      for(i in colnames(other_groups)){
            print(i)
            print(other_groups[,i] )
      }
      

      # Now we are ready to prune trees so that we get tree names match with species in data
      pruned_trees <- mapply(x = taxa_data_list, 
                             y = trees, 
                             function(x,y) tree_checks(x,y, "spp_name_phylo", type = "prune"))

  # set colours for nodes (we are using SSD as our basis for colour: female-biased = red, male-biased = blue)      
cols <- c("red3", "white","deepskyblue2") #can I make this continuous?

 # tree structure (cladogram, circular)
p <- ggtree(birdtree, branch.length='none', layout='circular') %<+% bird_data + 
  geom_tippoint(aes(color=SSD_index)) + 
  scale_color_manual(values=cols) + 
  geom_tiplab2(aes(label=spp_name_phylo), align=T, linetype=NA, 
              size=2, offset=4, hjust=0.5) +
  geom_tiplab2(aes(label=total_effects), align=T, linetype=NA, 
              size=2, offset=8, hjust=0.5)

#Personalising the colour gradient, ignore if you want default rainbow
length(init.tree$cols)

#Setting the colours
init.tree$cols[1:1001]<-colorRampPalette(colors=c("red3", "white","deepskyblue2"), space="Lab")(1001) #Red to blue
```
 

# will also need to indicate where species have been substituted 
```{r}
# load packages
pacman::p_load(dplyr, magrittr, ggplot2, patchwork, phylotools, diversitree, phytools)

# rejig dataframe so it has the data we need to plot (i.e. make SSD a binary category so its either male or female biased)
pers_new$SSD_binary <- ifelse(pers_new$SSD_index>0, 1, 0) #male-biased = 1, female-biased = 0

# now we should make a specific dataset for these trees because our data is a bit weird
  # what we need: species_name, taxo_group, spp_name_phylo, ssd_binary, personality_trait and no. effect sizes (n=length()))

pers_tree_ssd <- pers_new %>% dplyr::select(species_name, spp_name_phylo, taxo_group, SSD_binary, personality_trait)

# need to add a row for no. effect sizes for each species (spp_name_phylo) per personality trait
 n <- pers_tree_ssd %>%
      group_by(taxo_group, spp_name_phylo, personality_trait) %>%
      summarise(n = n())

```

# read in trees seperately?
```{r}
bird_tree <- trees[[1]]
```

# tree 1) categorical data
```{r}
#1) your categorical variable 
# subset dataset
  pers_bird <- as.data.frame(pers_tree_ssd %>%
    filter(taxo_group == "bird"))

ssd_bird <- pers_bird %>% dplyr::select(SSD_binary)                                                                                                                                                           
##) 2) Species name that matches tree tip labels as ROWNAMES of this dataframe
rownames(ssd_bird) <- unique(pers_bird$spp_name_phylo) #not working
  # need to sort this out since we have duplicates in the dataset, also some species represented by others
  # not sure how to resolve this one

# let's try and just make our bird tree first to see what it looks like
## Plot bird phylogeny as fan
trait.plot(bird_tree, pers_new$SSD_binary, 
           cols = list("Sexual size dimorphism" = c("#F2AD00", "#446455")), 
           cex.lab = 0.01, 
           legend = T, 
           w = 4/50,
           margin = 0)
```

